/**
 * @file
 *
 * Declarations that specify the data that we process.  This
 * includes the stream schema that we assume.
 *
 * @author Jens Teubner <jens.teubner@inf.ethz.ch>
 *
 * (c) 2010 ETH Zurich, Systems Group
 *
 * $Id: data.h 600 2010-08-13 13:36:53Z jteubner $
 *
 * We assume two input streams:
 *
 *  # stream R (left input): [ x:int, y:float, z:char[20] ]
 *    .
 *  # stream S (right input): [ a:int, b:float, c:double, d:bool ]
 *
 * Join is performed over the first two columns.
 *
 * All workers operate on a column-based storage.  Effectively, they
 * will only inspect the two join columns, and further columns need
 * not be transferred over the memory bus (this was done in CellJoin,
 * too).
 *
 * On every NUMA node, the worker that first receives a chunk of data
 * from a different node copies that chunk into local memory.  This
 * should further reduce memory bus usage and lead to a very
 * well-organized data flow over the HyperTransport/QPI links.
 */

#include "config.h"
#include "parameters.h"

#include <stdbool.h>

#ifndef DATA_H
#define DATA_H

/**
 * Tuples as they are generated by the data generator (left input; stream R).
 *
 * The schema [ x:int, y:float, z:char[20] ] is adapted from the
 * CellJoin paper.
 */
typedef int   x_t;
typedef float y_t;
typedef char  z_t[20];

/**
 * Tuples as they are generated by the data generator (right input).
 *
 * The schema [ a:int, b:float, c:double, d:bool ] is adapted from the
 * CellJoin paper.
 */
typedef int    a_t;
typedef float  b_t;
typedef double c_t;
typedef bool   d_t;

struct master_ctx_t;
void generate_data (struct master_ctx_t *ctx);

#endif  /* DATA_H */
